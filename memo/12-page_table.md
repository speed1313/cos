今のままだと, メモリ空間が連続しており, スタックが伸びるとそのまま別のプロセスにアクセスできてしまう.

そこで, ページテーブルを用いてメモリ空間を分割し, プロセスごとにメモリ空間を割り当てる.


cpuにページング機構が備わっている(!!)ため, RISC-Vのページング機構のうちSv32というモードを使用する.

Sv32は2段構造のページテーブルで, 索引が2段階になっている.


ヒープ領域にページテーブルを置く.
そして, 仮想アドレスと物理アドレスの対応をページテーブルに記録する.

[x] 本書では、カーネルのマッピングは、カーネルの仮想アドレスと物理アドレスが一致するように設定します。こうすることで、ページングを有効化しても同じコードを引き続き実行できるようになります。<- カーネルが全ての物理アドレスにアクセスできるようにするため

sfence.vma命令で, ページテーブルの変更をしっかり完了させることを, TLBキャッシュを消すなどをして保証する(メモリフェンス)

create_process時にカーネルのページをマッピングしている. 今の所同じ物理アドレスにマッピングしているが, これはカーネルの仮想アドレスと物理アドレスが一致するように設定しているため.



# EXITしたプロセスのpage tableの解放
- Sv32では, 2段構造のページテーブルを使用している.
- カーネル, virtioはlevel2のページをallocして確保する.
- ユーザはlevel2及び物理ページのページをallocして確保する.
- そこで, page_tableアドレスから全探索し, level2のページは全て開放, 物理ページはユーザのもの(PAGE_U bitが立っているもの)のみ開放する.


